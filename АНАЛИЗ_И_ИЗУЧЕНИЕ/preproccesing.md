
### Общая цель PreProcessor

Основная задача класса `PreProcessor` — взять "грязный" CSV-файл, где данные смешаны, имеют разный формат и записаны в неудобном виде, и превратить его в аккуратную таблицу. В этой новой таблице каждая колонка будет содержать только один тип информации (например, только числа, только текст или только даты), что делает данные пригодными для анализа, фильтрации и использования в других системах.

Процесс обработки можно представить как конвейер, который запускается в момент создания объекта `PreProcessor`. Давайте пройдем по каждому шагу этого конвейера.

---

### Шаг 1: Инициализация и базовая очистка (`__init__`)

Когда вы создаете объект `preprocessor = PreProcessor(csv_file_path=...)`, запускается метод `__init__`, который поочередно вызывает все остальные методы обработки.

1.  **Чтение данных**:
    `self.__df = pd.read_csv(csv_file_path, ...)`
    Скрипт читает ваш CSV-файл в DataFrame библиотеки Pandas. `dtype="unicode"` используется для того, чтобы все данные изначально читались как текст, избегая ошибок с типами.

2.  **Удаление лишних пробелов (`__del_space`)**:
    Пробегается по каждой ячейке и удаляет пробелы в начале и в конце.
    *   **Было**: `"  Арматура А1  "`
    *   **Стало**: `"Арматура А1"`

3.  **Замена пустых значений**:
    `self.__df = self.__df.replace(r"^\s*$", np.nan, ...)`
    Все ячейки, которые пусты или содержат только пробелы, заменяются на `NaN` (специальное значение в Pandas для отсутствующих данных). Это стандартный и правильный способ обработки пропусков.

После этих базовых операций начинаются самые интересные и сложные преобразования.

---

### Шаг 2: Обработка колонки "Размер" (`__preprocessing_size_col`)

Эта колонка — одна из самых сложных. В ней могут быть и простые числа (диаметр), и сложные обозначения балок.

*   **Проблема**: В колонке "Размер" находятся данные разного типа: `16`, `60Б1`, `25Ш1`. Анализировать такую колонку напрямую невозможно.
*   **Решение**: Метод `parse_size` использует серию регулярных выражений (шаблонов), чтобы определить тип продукции и извлечь из строки её характеристики. Он работает как водопад: если строка подходит под первый шаблон, она обрабатывается и функция завершается; если нет — проверяется следующий шаблон и так далее.

**Пример 1: Простой размер (строка 1)**

*   **Вход**: `Размер` = `"16"`
*   **Логика**: Строка не подходит под шаблоны для профилей, рельсов и т.д. Она попадает под "Шаблон 10: Простое число".
*   **Результат**: Создаются новые колонки:
    *   `Тип_продукции`: "Число"
    *   `Размер_A`: 16.0

**Пример 2: Сложный профиль (строка 212)**

*   **Вход**: `Размер` = `"60Б1"`
*   **Логика**: Строка идеально подходит под "Шаблон 1: Профили по ГОСТ/СТО". Регулярное выражение `(\d+)([А-Яа-я]+)(\d+)([А-Яа-я]?)` разбивает строку на части.
*   **Результат**:
    *   `Тип_продукции`: "Профиль ГОСТ/СТО"
    *   `Типоразмер`: 60
    *   `Марка`: "Б1"

> **Итог шага**: Вместо одной "грязной" колонки "Размер" появляются новые, структурированные колонки: `Тип_продукции`, `Марка`, `Типоразмер`, `Размер_A`, `Размер_B`, `Размер_C` и `Примечание_для_размера`.

---

### Шаг 3: Обработка колонки "Доп. размер" (`__preprocessing_extra_size_col`)

Эта колонка содержит информацию о длине, упаковке и прочие примечания.

*   **Проблема**: В колонке `Доп. размер` смешаны данные: `11.7` (длина), `бухты` (упаковка), `6-11.7` (диапазон длин), `н/д` (мусор).
*   **Решение**: Метод `extract_all_data` сначала ищет информацию об упаковке ("бухты", "мотки"). Затем, из оставшегося текста, с помощью регулярных выражений извлекает числовые значения длин.

**Пример 1: Указана упаковка (строка 6)**

*   **Вход**: `Доп. размер` = `"бухты"`
*   **Логика**: Код находит слово "бухты", записывает его в отдельную переменную и удаляет из текста. Текст становится пустым.
*   **Результат**:
    *   `Упаковка`: "бухты"
    *   `Минимальная_длина`: NaN
    *   `Максимальная_длина`: NaN

**Пример 2: Диапазон длин (строка 20)**

*   **Вход**: `Доп. размер` = `"6-11.7"`
*   **Логика**: Срабатывает "Вариант 1", который ищет диапазон "число-число".
*   **Результат**:
    *   `Упаковка`: NaN
    *   `Минимальная_длина`: 6.0
    *   `Максимальная_длина`: 11.7

> **Итог шага**: Колонка "Доп. размер" преобразуется в `Минимальная_длина`, `Максимальная_длина`, `Упаковка` и `Примечание_для_цены`.

---

### Шаг 4: Обработка колонки "Сталь" (`__process_steel_col`)

Здесь извлекается информация о материале.

*   **Проблема**: Колонка `Сталь` содержит разные марки стали (`ст3`, `А240`, `09Г2С`, `25Г2С`), которые можно классифицировать.
*   **Решение**: Применяется несколько функций:
    1.  **`get_material_type`**: Определяет общий тип материала (Сталь, Нержавеющая сталь, Алюминиевый сплав и т.д.) по ключевым словам.
    2.  **`get_primary_grade`**: Выделяет основную марку (например, из "3пс/сп" берет "3пс").
    3.  **Определение свариваемости**: Проверяет, заканчивается ли марка на "С" (например, `А500С`), что является признаком хорошей свариваемости.

**Пример (строка 66):**

*   **Вход**: `Сталь` = `"А500С"`
*   **Логика**:
    *   `get_material_type` вернет "Сталь".
    *   `get_primary_grade` вернет "а500с".
    *   Проверка на свариваемость найдет "с" в конце и вернет `1`.
*   **Результат**:
    *   `Тип_материала`: "Сталь"
    *   `Основная_марка`: "а500с"
    *   `Свариваемость`: 1

> **Итог шага**: Появляются колонки `Тип_материала`, `Основная_марка`, `Свариваемость`. Исходная колонка "Сталь" переименовывается в "Материал".

---

### Шаг 5: Обработка колонки "ГОСТ" (`__process_gost_col`)

*   **Проблема**: ГОСТ записан строкой вида `"ГОСТ 34028-2016"`. Для анализа полезно иметь тип, номер и год стандарта отдельно.
*   **Решение**: Используется одно регулярное выражение, которое сразу "разбирает" строку на три части.

**Пример (строка 1):**

*   **Вход**: `ГОСТ` = `"ГОСТ 34028-2016"`
*   **Результат**:
    *   `Тип_стандарта`: "ГОСТ"
    *   `Номер_стандарта`: "34028"
    *   `Год_стандарта`: 2016

> **Итог шага**: Вместо одной колонки "ГОСТ" появляются три: `Тип_стандарта`, `Номер_стандарта`, `Год_стандарта`.

---

### Шаг 6: Объединение колонок с ценами (`__union_price_cols`)

Это одно из самых мощных преобразований.

*   **Проблема**: Цена может быть в любой из нескольких колонок (`Цена, р./т`, `Цена, р./шт.` и т.д.). В ячейках может быть цена с условием (`48 500 >1т`) или текст (`звоните`). Нужно привести всё к единому виду.
*   **Решение**:
    1.  Все колонки с ценами "схлопываются" в одну длинную серию с помощью `stack()`.
    2.  Для каждой строки оставляется только **последняя** указанная цена (`drop_duplicates(keep="last")`).
    3.  Отдельно обрабатываются значения "звоните" — для них создается булева колонка `Звоните`.
    4.  С помощью регулярного выражения цена отделяется от условия (`"48 500 >1т"` → `48500` и `">1т"`).
    5.  Числовая цена преобразуется в тип `float`.

**Пример (строка 1):**

*   **Вход**:
    *   `Цена, р./т`: "48 500 >1т"
    *   `Цена, р./шт.`: NaN
    *   ... (остальные цены NaN)
*   **Логика**: `stack()` найдет только одно значение. Регулярное выражение разделит его на число и условие.
*   **Результат**:
    *   `Цена`: 48500.0
    *   `Категория_цены`: "р./т"
    *   `Условие_цены`: ">1т"
    *   `Звоните`: False

> **Итог шага**: Множество колонок `Цена, ...` заменяются на четыре новые: `Цена`, `Категория_цены`, `Условие_цены` и `Звоните`.

---

### Шаг 7: Финальная очистка

В конце метода `__init__` удаляются исходные "грязные" колонки, которые были полностью заменены новыми:

```python
del self.__df["Доп. размер"]
del self.__df["Размер"]
del self.__df["Материал"]
```

### Заключение

Таким образом, класс `PreProcessor` выполняет сложную работу по **инженерному конструированию признаков (feature engineering)**. Он не просто чистит данные, а извлекает из хаотичных текстовых полей ценную структурированную информацию и создает на её основе совершенно новые, готовые к использованию признаки. После его работы таблица становится из набора текста в мощный инструмент для анализа данных.
